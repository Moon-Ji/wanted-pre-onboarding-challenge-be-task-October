## 1. 동시에 같은 DB Table row 를 업데이트 하는 상황을 방어하기 위해 어떻게 개발하실 건지 설명해주세요.

여러 사용자가 데이터베이스를 동시에 공유할 수 있도록 여러 개의 트랜잭션이 동시에 수행되는 것을 병행 수행(concurrency)라고 한다. 그런데 병행 수행되는 트랜잭션들이 동시에 같은 데이터에 접근하여 변경 연산을 실행하려고 하면 예상치 못한 결과가 나올 수 있다. 따라서 병행 수행을 하더라도 각 트랜잭션들이 다른 트랜잭션의 방해를 받지 않고 정확한 결과를 얻을 수 있도록 제어해야하고 이렇게 트랜잭션의 수행을 제어하는 것을 `동시성 제어`라고 한다.

동시성 제어 기법은 여러 트랜잭션을 병행 수행하면서도 직렬 수행한 것 같은 결과를 얻을 수 있는 직렬 가능성을 보장받기 위해 하용한다. 직렬 가능성이 보장되는 규약을 정의해 모든 트랜잭션들이 이 규약을 따르도록 하여 동시성을 제어한다. 동시성 제어 기법은 여러 가지가 있는데 이 중 `로킹 기법`이 가장 많이 사용된다.

### 로킹(locking) 기법
로킹 기법은 병행 수행되는 트랜잭션들이 동일한 데이터에 동시에 접근하지 못하도록 lock과 unlock이라는 연산을 이용해 제어한다. 한 트랜잭션이 먼저 접근한 데이터에 대한 연산을 모두 마칠 때까지, 해당 데이터에 다른 트랜잭션이 접근하지 못하도록 막아 직렬 가능성을 보장한다. 

**기본 로킹 규약**   
lock 연산은 트랜잭션이 사용할 데이터에 대한 독점권을 가지는 연산이고, unlock 연산은 트랜잭션이 데이터에 대한 독점권을 반납하는 연산이다. 트랜잭션이 데이터에 접근하는 연산을 실행하려면 먼저 해당 데이터에 lock 연산을 실행해 독점권을 획득해야 한다. 즉, read 또는 write 연산을 실행하기 전에는 반드시 lock 연산을 실행해야 한다. 이후 트랜잭션이 독점권을 획득한 데이터에 대한 모든 연산을 수행하고 나면 unlock 연산을 실행해 독점권을 반납해야 한다. 이때 해당 데이터에 lock 연산을 실행한 트랜잭션만 해당 데이터에 unlock 연산을 실행할 수 없다. 

**2단계 로킹 규약**   
그러나 기본 로킹 규약만으로는 트랜잭션 스케줄의 직렬 가능성을 완벽하게 보장할 수 없다. 이 문제를 해결하고 트랜잭션의 직렬 가능성을 보장하기 위해 2단계 로킹 규약이 추가되었다. 2단계 로킹 규약은 lock과 unlock 연산을 2단계로 나누어 실행해야 한다.  

|확장 단계| 트랜잭션이 lock 연산만 실행할 수 있고, unlock 연산은 실행할 수 없는 단계|
|---|---|
|**축소 단계**| **트랜잭션이 unlock 연산만 실행할 수 있고, lock 연산은 실행할 수 없는 단계**|  

트랜잭션이 처음에 수행되면 확장 단계로 들어가 lock 연산만 실행할 수 있다. 이후 unlock 연산을 실행하면 축소 단계로 들어가 그때부터는 unlock 연산만 실행할 수 있다. 따라서 첫 번째 unlock 연산을 실행하기 전에 필요한 모든 lock 연산을 실행해야 한다.
